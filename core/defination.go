package core

type AutoGenerated struct {
	ID       string `json:"id"`
	Metadata struct {
		Operation string `json:"operation"`
		Provider  string `json:"provider"`
		Schema    string `json:"schema"`
	} `json:"metadata"`
	Results []struct {
		ID             string `json:"id"`
		Language       string `json:"language"`
		LexicalEntries []struct {
			Entries []struct {
				Etymologies    []string `json:"etymologies"`
				Pronunciations []struct {
					AudioFile        string   `json:"audioFile"`
					Dialects         []string `json:"dialects"`
					PhoneticNotation string   `json:"phoneticNotation"`
					PhoneticSpelling string   `json:"phoneticSpelling"`
				} `json:"pronunciations"`
				Senses []struct {
					Definitions []string `json:"definitions"`
					Examples    []struct {
						Text string `json:"text"`
					} `json:"examples,omitempty"`
					ID               string   `json:"id"`
					ShortDefinitions []string `json:"shortDefinitions"`
					Subsenses        []struct {
						Definitions []string `json:"definitions"`
						Examples    []struct {
							Text string `json:"text"`
						} `json:"examples,omitempty"`
						ID               string   `json:"id"`
						ShortDefinitions []string `json:"shortDefinitions"`
						Synonyms         []struct {
							Language string `json:"language"`
							Text     string `json:"text"`
						} `json:"synonyms,omitempty"`
						ThesaurusLinks []struct {
							EntryID string `json:"entry_id"`
							SenseID string `json:"sense_id"`
						} `json:"thesaurusLinks,omitempty"`
					} `json:"subsenses,omitempty"`
					Synonyms []struct {
						Language string `json:"language"`
						Text     string `json:"text"`
					} `json:"synonyms,omitempty"`
					ThesaurusLinks []struct {
						EntryID string `json:"entry_id"`
						SenseID string `json:"sense_id"`
					} `json:"thesaurusLinks,omitempty"`
					Regions []struct {
						ID   string `json:"id"`
						Text string `json:"text"`
					} `json:"regions,omitempty"`
					Registers []struct {
						ID   string `json:"id"`
						Text string `json:"text"`
					} `json:"registers,omitempty"`
				} `json:"senses"`
			} `json:"entries"`
			Language        string `json:"language"`
			LexicalCategory struct {
				ID   string `json:"id"`
				Text string `json:"text"`
			} `json:"lexicalCategory"`
			Text string `json:"text"`
		} `json:"lexicalEntries"`
		Type string `json:"type"`
		Word string `json:"word"`
	} `json:"results"`
	Word string `json:"word"`
}

type neatAutoGenerated struct {
	ID       string         `json:"id"`
	Phonetic string         `json:"phonetic,omitempty"`
	Audio    string         `json:"audio"`
	Results  []*neatLexical `json:"results"`
}
type neatSenses struct {
	Definitions      []string `json:"definitions,omitempty"`
	ShortDefinitions []string `json:"shortDefinitions,omitempty"`
	Examples         []string `json:"examples,omitempty"`
	Synonyms         []string `json:"synonyms,omitempty"`
}

type neatLexical struct {
	Category string        `json:"category"`
	Senses   []*neatSenses `json:"senses"`
}

func NeatAutoGenerated(a *AutoGenerated) (n *neatAutoGenerated) {
	n = &neatAutoGenerated{
		ID: a.ID,
	}

	if len(a.Results[0].LexicalEntries[0].Entries[0].Pronunciations) > 0 {
		n.Phonetic = a.Results[0].LexicalEntries[0].Entries[0].Pronunciations[0].PhoneticSpelling
		n.Audio = a.Results[0].LexicalEntries[0].Entries[0].Pronunciations[0].AudioFile
	}

	n.Results = make([]*neatLexical, 0, 10)
	for _, v := range a.Results[0].LexicalEntries {
		lexical := new(neatLexical)
		lexical.Category = v.LexicalCategory.Text
		lexical.Senses = make([]*neatSenses, 0, len(v.Entries))
		for _, s := range v.Entries[0].Senses {
			senses := &neatSenses{
				Definitions:      s.Definitions,
				ShortDefinitions: s.ShortDefinitions,
				Synonyms:         make([]string, 0, len(s.Synonyms)),
				Examples:         make([]string, 0, len(s.Examples)),
			}
			for _, str := range s.Synonyms {
				senses.Synonyms = append(senses.Synonyms, str.Text)
			}
			for _, str := range s.Examples {
				senses.Examples = append(senses.Examples, str.Text)
			}
			lexical.Senses = append(lexical.Senses, senses)
		}
		n.Results = append(n.Results, lexical)
	}
	return
}
